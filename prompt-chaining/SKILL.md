# Prompt Chaining — 链式提示技能

## 概述

Prompt Chaining（链式提示）是一种将复杂任务分解为多个有序阶段的提示工程方法。每个阶段的输出作为下一阶段的输入，通过逐步精炼来获得高质量的最终结果。

本技能定义了一个**五阶段链式流程**，适用于软件工程中的各类任务。

---

## 触发条件

当遇到以下情况时，应自动激活链式提示流程：

- 任务涉及多个文件或模块的修改
- 需求描述模糊，需要先澄清再执行
- 任务复杂度较高，直接一步到位容易出错
- 涉及架构决策或技术选型
- 需要在多个方案中做出权衡取舍

**不需要激活的场景：**

- 单文件的小幅修改（如改个变量名、修复拼写错误）
- 用户给出了明确且完整的指令
- 纯信息查询类问题

---

## 五阶段链式流程

### 第一阶段：分析（Analyze）

**目标：** 深入理解任务上下文，明确约束条件。

**操作：**
1. 解析用户需求，提取关键意图
2. 扫描相关代码文件和目录结构
3. 识别当前代码的模式和约定（命名风格、架构模式、测试策略等）
4. 列出已知约束（技术栈、兼容性要求、性能目标）
5. 标记不确定或模糊的部分

**输出：** 一份结构化的分析摘要，包含：
- 任务理解（用自己的话复述需求）
- 影响范围（涉及哪些文件/模块）
- 约束清单
- 待澄清问题（如有）

### 第二阶段：生成（Generate）

**目标：** 基于分析结果，生成多个可行方案。

**操作：**
1. 根据分析产出至少 2-3 个不同的实现方案
2. 每个方案需包含：
   - 核心思路描述
   - 关键实现步骤
   - 优点与局限
   - 对现有代码的侵入程度
3. 考虑边缘情况和潜在风险

**输出：** 方案列表，每个方案附带简要的利弊分析。

### 第三阶段：选择（Select）

**目标：** 从多个方案中选出最优解。

**操作：**
1. 对比各方案在以下维度的表现：
   - **正确性**：能否完整满足需求
   - **简洁性**：实现是否足够简单
   - **一致性**：是否符合现有代码风格和架构
   - **可维护性**：后续修改是否方便
   - **风险**：引入 bug 或破坏现有功能的概率
2. 综合评估后选定方案
3. 如果没有明显最优方案，向用户呈现关键权衡点并请求决策

**输出：** 选定的方案及选择理由。

### 第四阶段：补充证据（Supplement）

**目标：** 为选定方案补充实现细节和验证策略。

**操作：**
1. 细化实现步骤，精确到每个文件的每处修改
2. 识别需要的测试用例
3. 检查是否有遗漏的依赖或配置变更
4. 考虑回滚策略
5. 如有必要，阅读更多源码以确认假设

**输出：** 详细的实施计划，包含：
- 按顺序排列的修改清单
- 测试策略
- 风险缓解措施

### 第五阶段：综合（Synthesize）

**目标：** 执行方案并产出最终结果。

**操作：**
1. 按照实施计划逐步执行修改
2. 每完成一个步骤，验证中间结果
3. 如遇到预期外的情况，回溯到相应阶段重新评估
4. 完成所有修改后进行整体自检
5. 生成变更摘要供用户审查

**输出：** 完成的代码变更 + 变更摘要。

---

## 任务规模适配

链式流程并非一成不变，应根据任务规模灵活调整：

### 小型任务（预计改动 < 3 个文件）

- **精简模式**：合并「分析」和「生成」阶段，快速定位方案
- 可跳过显式的多方案对比
- 直接进入实施，但仍需在脑中完成选择过程

### 中型任务（3-10 个文件）

- **标准模式**：完整执行五阶段流程
- 每阶段产出可以简洁但不可省略
- 重点关注文件间的依赖关系

### 大型任务（> 10 个文件或涉及架构变更）

- **深度模式**：每阶段都需要详细展开
- 在「分析」阶段增加架构评审
- 在「生成」阶段考虑分批实施策略
- 在「补充证据」阶段加入更全面的测试覆盖分析
- 考虑将任务拆分为多个独立的小链

---

## 常见反模式

### 1. 跳过分析直接编码

**表现：** 看到需求就开始写代码，不先理解上下文。

**后果：** 产出的代码与项目风格不一致，遗漏关键约束，返工成本高。

**纠正：** 始终先读代码再写代码。至少花 20% 的时间在理解上。

### 2. 只生成一个方案

**表现：** 第一个想到的方案就直接用了。

**后果：** 错过更简洁或更合适的实现方式。

**纠正：** 强制自己想出至少两种不同的方式，即使最终还是选了第一种。

### 3. 过度设计

**表现：** 为了应对假设的未来需求，引入不必要的抽象和复杂度。

**后果：** 代码变得难以理解和维护，偏离了实际需求。

**纠正：** 只解决当前的问题。三行重复代码好过一个过早的抽象。

### 4. 忽视上下文一致性

**表现：** 新写的代码采用了和项目现有代码不同的风格或模式。

**后果：** 代码库整体一致性下降，增加认知负担。

**纠正：** 在分析阶段明确识别并遵循项目的现有约定。

### 5. 链条断裂

**表现：** 在某个阶段遇到困难后直接跳到最终实施，丢弃中间推理。

**后果：** 最终方案缺乏充分论证，容易遗漏关键问题。

**纠正：** 遇到困难时回溯到上一阶段，而不是跳过当前阶段。

---

## 核心原则

1. **逐步精炼优于一步到位** — 分阶段处理让每一步都更可控
2. **显式推理优于隐式假设** — 把思考过程外化，减少遗漏
3. **多方案对比优于单一路径** — 比较才能发现各方案的优劣
4. **上下文感知优于模板套用** — 每个项目都有自己的约定，需要尊重
5. **灵活适配优于僵化执行** — 流程为人服务，不是人为流程服务
