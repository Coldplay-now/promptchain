# LessonLearn — 项目经验复盘技能

## 概述

LessonLearn 是一个项目经验复盘技能。它帮助开发者从当前项目中提炼经验教训，生成结构化的学习报告，用于指导后续开发工作。

核心特点：
- **深度优先**：不做泛泛扫描，聚焦最有价值的发现，每条教训都具体可操作
- **AI 自适应**：根据项目特征和当前阶段自动选择分析重点
- **增量积累**：报告支持追加更新，随项目演进持续沉淀经验
- **务实导向**：面向开发者个人复盘，措辞直接，重在指导后续工作

---

## 触发条件

当遇到以下情况时，应激活 LessonLearn 技能：

- 用户要求"总结经验"、"复盘"、"学到了什么"、"经验教训"
- 用户要求"生成学习报告"、"项目回顾"
- 用户在完成一个阶段性工作后希望做总结

**不需要激活的场景：**

- 用户只是在讨论具体的技术问题
- 纯代码编写或调试任务
- 用户要求的是项目文档（README、API doc 等），而非经验总结

---

## 四阶段复盘流程

### 第一阶段：扫描（Scan）

**目标：** 全面收集项目信息，建立项目画像。

**操作：**
1. 扫描项目目录结构，识别技术栈和项目类型
2. 读取关键配置文件（package.json、tsconfig、Dockerfile 等）
3. 分析 Git 历史：提交频率、提交模式、贡献者
4. 识别热点文件（被频繁修改的文件）
5. 检查测试覆盖、CI/CD 配置、文档完善度
6. 扫描依赖状态（过时、安全漏洞、依赖数量）

**输出：** 项目画像摘要，包含：
- 技术栈和项目规模
- 项目当前阶段（初创、迭代、维护）
- 各维度的健康度概览

### 第二阶段：聚焦（Focus）

**目标：** 根据项目画像，自动选择最值得深入分析的 2-3 个重点维度。

**选择依据：**

| 项目信号 | 建议聚焦 |
|----------|---------|
| 热点文件集中在少数模块 | 架构设计与模块边界 |
| Git 中有大量 revert/fix 提交 | 质量与流程问题 |
| 依赖过时或存在安全漏洞 | 依赖管理策略 |
| 测试文件缺失或覆盖率低 | 测试策略 |
| 单文件超过 500 行 | 代码组织与可维护性 |
| 提交信息混乱或无规范 | 工程规范与协作 |
| 近期提交密集在某个功能 | 该功能的设计决策复盘 |
| 配置文件复杂 | 构建与部署优化 |

**操作：**
1. 根据扫描结果匹配上表，选出最相关的 2-3 个维度
2. 向用户说明选择理由，确认分析方向
3. 如用户有特定关注点，优先纳入

**输出：** 确认的分析维度及选择理由。

### 第三阶段：深挖（Dig）

**目标：** 对每个聚焦维度进行深度分析，提炼具体教训。

**操作：**
1. 针对每个维度，阅读相关源码和历史
2. 识别做得好的实践（值得保持）
3. 识别问题模式（需要改进）
4. 对每个发现，追问"为什么会这样"和"下次怎么做更好"
5. 给出具体的改进建议（精确到可操作的步骤）

**每条教训的结构：**
```
### [教训标题]

**发现：** 具体描述观察到的现象
**根因：** 为什么会出现这种情况
**影响：** 对项目造成了什么影响
**建议：** 下次应该怎么做（具体可操作）
**相关文件：** 涉及的关键文件路径
```

**深度要求：**
- 不要停留在"代码需要重构"这种泛泛结论
- 要指出具体是哪个文件的哪个问题、为什么成了问题、怎么改
- 好的实践同样要具体：不是"测试写得好"，而是"xx 模块用了 xx 模式来隔离依赖，使得测试可以独立运行"

**输出：** 每个维度的深度分析结果，含具体教训列表。

### 第四阶段：报告（Report）

**目标：** 将分析结果整理为结构化的 Markdown 报告文件。

**操作：**
1. 如果是首次生成，创建新报告文件（含元数据和目录）
2. 如果报告已存在，在文尾追加新内容并更新目录
3. 根据需要决定是否加入可视化（架构图、依赖关系图等）
4. 确保每条建议都具体可操作

**报告文件结构：**
```markdown
---
project: [项目名]
created: [首次创建日期]
last_updated: [最近更新日期]
total_reviews: [累计复盘次数]
---

# [项目名] 经验教训报告

## 目录
- [第 1 次复盘 - YYYY-MM-DD - 主题](#review-1)
- [第 2 次复盘 - YYYY-MM-DD - 主题](#review-2)
...

---

## 第 N 次复盘 - YYYY-MM-DD {#review-N}

### 项目快照
> 技术栈 | 代码规模 | 本次复盘聚焦维度

### 做得好的
...

### 需要改进的
...

### 行动项
- [ ] 具体行动 1
- [ ] 具体行动 2
...
```

**输出：** 保存到项目中的 Markdown 报告文件（默认路径 `docs/lessons-learned.md`）。

---

## 分析维度详解

AI 会根据项目情况从以下维度中自动选择，但不会每次都全部分析：

### 代码质量
- 重复代码：是否有可提取的公共逻辑
- 复杂度：圈复杂度过高的函数
- 命名：是否表意清晰、风格一致
- 文件组织：单文件是否过长、职责是否单一

### 架构决策
- 模块边界：模块间耦合是否合理
- 技术选型：选用的框架/库是否合适
- 数据流：数据在系统中的流转是否清晰
- 可扩展性：当前设计是否能支撑后续需求

### Git 历史
- 热点文件：频繁修改的文件（可能是设计不稳定的信号）
- Revert 记录：踩过的坑
- 提交模式：是否有清晰的提交规范
- 分支策略：工作流是否合理

### 依赖管理
- 依赖数量：是否合理
- 版本状态：是否有过时的依赖
- 安全漏洞：是否有已知安全问题
- 锁文件：是否正确使用了 lock 文件

### 工程实践
- 测试策略：覆盖率、测试类型、测试质量
- CI/CD：自动化流程是否完善
- 文档：是否有必要的文档
- 开发体验：本地开发流程是否顺畅

---

## 任务规模适配

### 快速复盘（小型项目 / 单模块）

- 合并「扫描」和「聚焦」阶段
- 聚焦 1-2 个最突出的维度
- 报告简短精炼，重点在行动项

### 标准复盘（中型项目）

- 完整四阶段流程
- 聚焦 2-3 个维度
- 每个维度 2-4 条具体教训

### 深度复盘（大型项目 / 阶段性总结）

- 每阶段充分展开
- 可覆盖 3-5 个维度
- 增加可视化：架构图、依赖关系图、热点文件图
- 行动项按优先级排序，区分短期和长期

---

## 增量更新机制

报告文件支持增量追加，遵循以下规则：

1. **首次生成**：创建完整报告，包含元数据、目录和第 1 次复盘内容
2. **后续追加**：
   - 更新元数据中的 `last_updated` 和 `total_reviews`
   - 在目录中追加新条目
   - 在文件末尾追加新的复盘章节
3. **交叉引用**：如果新发现与之前的教训相关，用链接引用之前的章节
4. **行动项追踪**：之前的行动项如果已完成，可在新复盘中标记进展

---

## 常见反模式

### 1. 泛泛而谈

**表现：** "代码质量有待提高"、"需要加强测试"这类空洞结论。

**后果：** 报告看了等于没看，对实际工作毫无指导意义。

**纠正：** 每条教训都要具体到文件、到模式、到可操作的下一步。

### 2. 只看问题不看优点

**表现：** 整份报告全是批评和改进建议。

**后果：** 打击积极性，也遗漏了值得继续保持的好实践。

**纠正：** "做得好的"和"需要改进的"都要有，好的实践值得被显式记录。

### 3. 贪多求全

**表现：** 每个维度都想覆盖，每个文件都想分析。

**后果：** 分析浅尝辄止，教训缺乏深度，报告冗长难读。

**纠正：** 聚焦 2-3 个最有价值的维度，宁可少而深，不要多而浅。

### 4. 脱离上下文的建议

**表现：** 建议引入某个框架或模式，但不考虑项目的实际约束。

**后果：** 建议无法落地，浪费讨论时间。

**纠正：** 每条建议都要考虑项目的技术栈、团队规模和当前阶段。

### 5. 忽视历史演进

**表现：** 只看代码当前状态，不看它是怎么变成这样的。

**后果：** 可能误判问题根因，给出治标不治本的建议。

**纠正：** 结合 Git 历史理解代码演变，理解"为什么这样写"后再提建议。

---

## 核心原则

1. **深度优于广度** — 2-3 个深刻洞察胜过 10 条泛泛之谈
2. **具体优于抽象** — 指出具体文件、具体模式、具体行动
3. **面向行动优于面向评判** — 目的是指导"下次怎么做"，不是"做错了什么"
4. **尊重上下文优于套用标准** — 每个项目有自己的约束，建议要落地
5. **持续积累优于一次性报告** — 经验的价值在于随项目成长不断沉淀
