# 分析维度指南

本文档详细说明 LessonLearn 在各个分析维度上的具体检查点、分析方法和常见发现模式。

---

## 维度一：代码质量

### 检查点

| 检查项 | 怎么查 | 什么算问题 |
|--------|--------|-----------|
| 重复代码 | 搜索结构相似的代码块 | 3 处以上相似逻辑未提取公共函数 |
| 函数长度 | 统计函数行数 | 单个函数超过 80 行 |
| 文件长度 | 统计文件行数 | 单个文件超过 500 行 |
| 嵌套深度 | 检查 if/for/while 嵌套 | 嵌套超过 3 层 |
| 命名质量 | 审查变量和函数名 | 存在 data、info、temp、handle 等模糊命名 |
| 魔法数字 | 搜索硬编码的数字和字符串 | 业务逻辑中出现未解释的字面量 |
| 死代码 | 搜索未使用的导出和变量 | 存在注释掉的代码块或无引用的函数 |

### 常见发现模式

**"上帝文件"模式：**
```
发现：src/utils/helpers.ts 有 1200 行，包含 45 个导出函数，
涵盖日期处理、字符串格式化、权限校验、价格计算等完全不相关的功能。

根因：项目早期所有工具函数都往一个文件里放，后来没人愿意拆分。

建议：按职责拆分为 date-utils.ts、format-utils.ts、auth-utils.ts、
price-utils.ts，每个文件只包含相关函数。从被引用最少的函数开始拆。
```

**"复制粘贴"模式：**
```
发现：src/pages/ 下的 5 个列表页面，每个都有几乎相同的
分页逻辑（约 30 行），只有 API 端点和列名不同。

根因：第一个列表页写好后，后续页面直接复制修改。

建议：提取 usePaginatedList hook，接受 API 端点和列定义作为参数。
改造成本约 1 小时，未来新增列表页时节省时间。
```

---

## 维度二：架构决策

### 检查点

| 检查项 | 怎么查 | 什么算问题 |
|--------|--------|-----------|
| 模块边界 | 分析 import 关系 | 两个模块双向依赖 |
| 分层清晰度 | 检查各层之间的调用关系 | 表现层直接访问数据层，跳过业务层 |
| 职责分配 | 审查各模块的功能范围 | 一个模块承担了 3 种以上不相关的职责 |
| 技术选型适配度 | 对比需求和所选技术的能力 | 选用了重型框架解决简单问题 |
| 数据流清晰度 | 追踪数据的流转路径 | 同一份数据在多处变换格式 |
| 接口设计 | 审查模块间的接口定义 | 接口暴露了内部实现细节 |

### 常见发现模式

**"循环依赖"模式：**
```
发现：UserService 依赖 OrderService（获取用户的订单列表），
OrderService 又依赖 UserService（获取订单的用户信息），
形成循环依赖。

根因：两个服务之间缺少明确的边界定义，各自为了方便直接互相调用。

建议：引入 UserOrderQuery 作为独立的查询服务，或通过事件解耦。
短期方案：让 OrderService 只接受 userId 参数，
不再内部调用 UserService。
```

**"框架错配"模式：**
```
发现：项目用 Next.js 搭建，但 90% 的页面是纯客户端渲染，
没有使用 SSR/SSG，getServerSideProps 几乎为空壳。

根因：项目启动时预期会有 SEO 需求，实际上是内部后台系统。

影响：构建时间比用 Vite + React 长 3 倍，开发体验较重。

建议：如果确认不需要 SSR，下个大版本考虑迁移到 Vite。
短期内可以把所有页面标记为 'use client' 减少不必要的服务端处理。
```

---

## 维度三：Git 历史

### 检查点

| 检查项 | 怎么查 | 什么算问题 |
|--------|--------|-----------|
| 热点文件 | `git log --format='' -- FILE \| wc -l` | 单文件月修改超过 10 次 |
| Revert 频率 | `git log --grep='revert' -i` | 存在多次 revert（说明合入了有问题的代码） |
| 提交粒度 | 审查提交内容范围 | 单次提交涉及 10+ 个不相关文件 |
| 提交信息 | 审查 commit message | 大量 "fix"、"update"、"wip" 等无意义信息 |
| 分支生命周期 | 检查长期未合并的分支 | 存在超过 2 周未合并的 feature 分支 |
| 合并冲突热点 | 查看频繁发生冲突的文件 | 同一文件反复出现合并冲突 |

### 分析方法

**热点文件分析：**
```bash
# 查看最近 30 天内修改次数最多的文件
git log --since="30 days ago" --name-only --format='' | \
  sort | uniq -c | sort -rn | head -20
```

解读：
- 热点文件未必是问题，可能只是活跃开发区域
- 但如果一个"应该稳定"的基础模块频繁被修改，说明接口设计不够稳定
- 多个不相关功能的修改总是涉及同一文件，说明该文件职责过重

**Revert 分析：**
```bash
# 查看所有 revert 记录
git log --grep='revert' -i --oneline
```

解读：
- 每个 revert 背后都有一个教训
- 追问：为什么合入了有问题的代码？是测试不充分、还是 review 不够、还是需求理解有偏差？

**提交模式分析：**
```bash
# 查看提交信息模式
git log --oneline -50
```

解读：
- 好的模式：`feat: add user login`、`fix(order): resolve race condition`
- 坏的模式：`fix`、`update`、`wip`、`test`
- 提交信息的质量反映了团队的工程纪律

### 常见发现模式

**"一个文件打天下"模式：**
```
发现：src/store/index.ts 在过去 60 天内被修改了 47 次，
是第二名的 4 倍。几乎每个功能的开发都要改这个文件。

根因：所有状态管理集中在一个 store 文件中，没有按功能域拆分。

影响：多人开发时该文件是合并冲突的重灾区，
每次解决冲突都有引入 bug 的风险。

建议：按功能域拆分 store（userStore、orderStore、cartStore），
每个 store 独立维护自己的 state、actions 和 selectors。
```

---

## 维度四：依赖管理

### 检查点

| 检查项 | 怎么查 | 什么算问题 |
|--------|--------|-----------|
| 依赖数量 | 统计 dependencies 数量 | 生产依赖超过 50 个（中小项目） |
| 过时依赖 | 对比当前版本和最新版本 | 主要依赖落后 2 个以上大版本 |
| 安全漏洞 | `npm audit` / `yarn audit` | 存在 high 或 critical 级别的漏洞 |
| 锁文件 | 检查 lock 文件状态 | 锁文件未被 Git 追踪，或多个锁文件共存 |
| 未使用的依赖 | 检查 import 引用 | package.json 中声明了但代码中未使用的包 |
| 依赖重叠 | 检查功能重复的包 | 同时安装了 moment 和 dayjs，或 lodash 和 ramda |

### 常见发现模式

**"依赖膨胀"模式：**
```
发现：项目有 87 个生产依赖，其中 12 个只在 1 处被引用，
6 个完全没有被引用。

根因：开发过程中为了解决临时问题随手安装了包，
用完后没有清理。

建议：
1. 删除 6 个未引用的依赖
2. 评估 12 个单次引用的依赖，看能否用原生方法替代
3. 建立依赖引入的 review 流程，新增依赖需要说明理由
```

---

## 维度五：工程实践

### 检查点

| 检查项 | 怎么查 | 什么算问题 |
|--------|--------|-----------|
| 测试覆盖 | 检查测试文件和配置 | 核心业务逻辑没有测试 |
| 测试质量 | 审查测试代码 | 测试只验证"不报错"，不验证行为正确性 |
| CI/CD | 检查工作流配置 | 没有自动化的构建和测试流程 |
| 代码规范 | 检查 Linter 配置 | 没有 Linter，或 Linter 规则被大量 disable |
| 环境配置 | 检查 .env 管理 | 敏感信息硬编码在代码中 |
| 开发文档 | 检查 README 和注释 | 新人无法仅凭文档跑起项目 |

### 常见发现模式

**"伪测试"模式：**
```
发现：项目有 45 个测试文件，看起来覆盖率不错。
但仔细检查发现，80% 的测试只是调用了函数并 expect(result).toBeDefined()，
没有验证返回值的正确性。

根因：团队被要求"提高测试覆盖率"，但没有建立测试质量标准。

影响：测试给了虚假的安全感，重构时测试全过但功能已经坏了。

建议：
1. 为核心业务逻辑（订单、支付）重写测试，验证具体行为
2. 建立测试审查标准：每个测试必须至少有一个具体的值断言
3. 新增代码的测试要求验证正常路径 + 至少一个异常路径
```

---

## 维度选择策略

AI 在「聚焦」阶段按以下优先级选择分析维度：

### 优先级 1：有明显信号的维度

如果扫描阶段发现了强信号（如大量 revert、超长文件、安全漏洞），优先分析该维度。

### 优先级 2：与项目阶段相关的维度

| 项目阶段 | 优先维度 |
|----------|---------|
| 初创期（MVP） | 代码组织、技术选型 |
| 迭代期（功能扩展） | 架构决策、模块边界 |
| 维护期（稳定运行） | 依赖管理、工程实践 |
| 重构期（偿还技术债） | 代码质量、Git 历史 |

### 优先级 3：用户关注点

如果用户明确提到了某个维度或关注某类问题，将其纳入分析范围，即使 AI 的自动判断没有选中它。
